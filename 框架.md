# Maven
- 依赖管理：
- 项目的一键构建：编译、测试、运行、打包、安装、部署 整个过程都交给maven来进行管理。

## 1. 基础知识
安装配置全过程见：https://blog.csdn.net/a805814077/article/details/100545928
- 环境变量中添加 MAVEN_HOME=D:\Program Files\apache-maven-3.6.3
- Path 中添加 %MAVEN_HOME%\bin
- 默认本地仓库位置：`Default: ${user.home}/.m2/repository`，本地仓库没有时去中央仓库寻找
![wDcPtP.png](https://s1.ax1x.com/2020/09/14/wDcPtP.png)

- 修改本地仓库：`<localRepository>D:\maven_repository</localRepository>`
- maven项目结构：核心代码、配置文件、测试代码、测试配置文件
- 标准目录结构
  - `src/main/java` : 核心代码
  - `src/main/resources` : 配置文件
  - `src/test/java` : 测试代码
  - `src/test/resources` : 测试配置文件
  - `src/main/webapp` : 页面资源，js，css，图片等
## 2. 常用命令
- `mvn compile` : 编译src/main 放置在target中
- `mvn clean` : 清除本地编译信息，删除target目录
- `mvn test` : 编译**src/test和src/main**
- `mvn package` : 打包项目成.var(根据pom中`<packaging>war</packaging>`)，放置在target目录中
- `mvn install` : 将改项目编译，打包，并安装到本地仓库
- 整个项目构建过程：**清除项目编译信息(clean)、编译(compile)、测试(test)、打包(package)、安装(insatall)、发布(deploy)** 均有对应命令
- 生命周期：清理生命周期(clean)、**默认生命周期(compile->deploy)**、站点生命周期

## 3. maven 概念模型
![wDfGwQ.png](https://s1.ax1x.com/2020/09/14/wDfGwQ.png)

## 4. maven 的一些配置

- IDEA maven配置：Maven->Runner->VM Options:`-DarchetypeCatalog=internal`
- maven换源：推荐第一个

~~~xml
 <!-- 阿里云仓库 -->
        <mirror>
            <id>alimaven</id>
            <mirrorOf>central</mirrorOf>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
        </mirror>
     或者
      <mirror>
		<id>nexus-aliyun</id>
		<mirrorOf>*</mirrorOf>
        <name>Nexus aliyun</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
	 </mirror>
~~~
- 坑：`java: 程序包org.springframework.boot不存在` 新版IDEA需要在Setting里将 delegate IDE build/run actions to Maven勾选上即可
- 使用骨架创建web工程：Maven->Create from archtype->maven-archetype-webapp
- **jdk1.8以上需要运行tomcat7以上版本！！！！(默认是6)** ， 使用 `mvn tomcat7:run` 运行
~~~xml
        <plugin>
          <groupId>org.apache.tomcat.maven</groupId>
          <artifactId>tomcat7-maven-plugin</artifactId>
          <version>2.2</version>
          <configuration>
            <uriEncoding>UTF-8</uriEncoding>
            <path>/</path>
            <port>8080</port>
          </configuration>
        </plugin>
~~~
- **jar包冲突**：tomcat中有servlet和servlet.jsp包，所以冲突，解决办法：设置scope作用范围为 `provided`

~~~xml
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>
~~~
- **最后记得配置web.xml中的servlet映射：**

~~~xml
  <servlet>
    <servlet-name>MyServlet</servlet-name>
    <servlet-class>com.jj.servlet.MyServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>MyServlet</servlet-name>
    <url-pattern>/MyServlet</url-pattern>
  </servlet-mapping>
~~~

## 5. 常见的scope作用域例子

|依赖范围|编译classpath有效|测试classpath有效|运行时classpath有效|例子|
|---|:---:|:---:|:---:|---|
|compile|Y|Y|Y|spring-core|
|test|-|Y|-|Junit|
|**provided**|Y|Y|-|**servlet-api**|
|**runtime**|-|Y|Y|**JDBC驱动**|
|system|Y|Y|-|本地的，Maven仓库之外的类库<br>显示提供本地jar路径，一般不使用|

# MVC 和 三层架构
## MVC
Model View Controllor(模型，视图和控制器)，是一种软件的开发模式(不是设计模式)      

- **视图(View)：** 展示数据，与用户直接进行交互【JSP】
- **模型(Model)：** 完成具体的业务操作(查询数据库，封装对象)【JavaBean】
- **控制器(Controllor)：** 获取用户输入，调用相应的模型处理，将模型处理的结果交给视图展示【Servlet】 

**优点：** 低耦合，方便维护，有利于分工合作，重用性高           
**缺点：** 项目架构变得复杂         

## 三层架构  
软件设计架构            
- 视图层、界面层(View层/web层)：接收用户请求，用户可以通过界面上的组件和服务器进行交互
- 服务层、业务逻辑层(Service层)：系统的业务逻辑      
- 持久层、数据访问层(Dao层)：直接操作数据库      

![三层架构.png](https://s1.ax1x.com/2020/08/20/d3j1BD.png)

为了更好的降低各层间的耦合度，在三层架构程序设计中，采用**面向抽象编程**。即上层对下层的调用，是通过**接口**实现的。而下层对上层的真正服务提供者，是下层**接口的实现类**        

## MVC与三层架构的关系
三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层
![MVC和三层架构的关系.png](https://s1.ax1x.com/2020/08/20/d3LGAs.png)

## 三层架构和各个框架的关系
![wXPDB9.png](https://s1.ax1x.com/2020/09/22/wXPDB9.png)

# MyBatis
- **mybatis** 是优秀的java**持久层框架**，内部**封装了jdbc操作的很多细节**，开发者只需要关注sql本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，它使用**ORM(Object Realtional Mapping 对象关系映射)** 思想实现了结果集的封装。
- **Hibernate** 也是持久层的一个解决方案
 
## 1. 原始jdbc存在的问题
- 数据库连接创建、释放频繁造成系统资源浪费影响系统性能------使用数据库连接池
- sql语句硬编码，不易维护，变动需要改变java代码------将sql语句抽取到xml配置文件中
- 查询结果需要手动封装到实体中，插入操作需要手动将实体数据设置到sql语句的占位------利用反射、内省等底层技术实现实体属性和表字段的映射

## 2. QuickStart 和 自定义mybatis功能
### 2.1 QuickStart-xml配置
1. 添加MyBatis的坐标
2. 创建user数据表
3. 创建实体类和Dao接口
4. 创建映射配置文件 IUserDao.xml
5. 创建mybatis主配置文件 SqlMapConfig.xml
6. 测试

**注意：**
1. 在Mybatis中，持久层的操作接口名称和映射文件也叫**Mapper**： IUserDao.xml  也写作 IUserMapper.xml
2. idea中创建目录的时候和包不同，包在创建com.jj.dao是三级结构，但是创建目录是一级结构：IUserDao.xml的目录**必须一级一级的创建**
3. mybatis的映射配置文件结构必须要和dao接口的包接口相同： `main/java/com/jj/dao/IUserDao`  和  `resources/com/jj/dao/IUserDao.xml`  必须一一对应
4. 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名
5. 映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名

遵守345规则之后，开发中无需再写dao的实现类了！
- **核心配置文件：sqlMapConfig.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
 <!-- mybatis的主配置文件 -->
<configuration>
    <!-- 配置环境 -->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!-- 配置数据源（连接池） -->
            <dataSource type="POOLED">
                <!-- 配置连接数据库的4个基本信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
                <property name="username" value="root"/>
                <property name="password" value="janshan123"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao的全限定类名
    -->
    <mappers>
        <mapper resource="com/jj/dao/IUserDao.xml"/>
        <!-- <mapper class="com.jj.dao.IUserDao"/> -->
    </mappers>
</configuration>
~~~
- **Mapper的配置：IUserDao.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jj.dao.IUserDao">
    <!--配置查询所有-->
    <select id="findAll" resultType="com.jj.domain.User">
        select * from user
    </select>
</mapper>
~~~

- 测试步骤如下：
~~~java
    public void test1() throws IOException {
        //1. 加载核心配置文件
        InputStream inputStream = Resources.getResourceAsStream("sqlMapConfig.xml");
        
        //2. 创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(inputStream);
        
        //3. 使用工厂生产SqlSession对象
        SqlSession session = factory.openSession();
        
        //4. 使用SqlSession创建Dao接口的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        
        //5. 使用代理对象执行Dao中的方法
        List<User> users = userDao.findAll();
        for(User user: users){
            System.out.println(user);
        }
        
        //6. 释放资源
        session.close();
        inputStream.close();
    }
~~~

#### 2.1.1 测试步骤详解
1. 加载核心配置文件
   - 使用绝对路径的写法不具有通用性，而相对路径写法在部署后src目录也没了，也不适用。均不使用
   - **使用类加载器：** 只能读取类路径的配置文件
   - **使用ServletContext对象的getRealPath()** 

2. 创建SqlSessionFactory工厂
   - 创建工厂时，mybatis使用了构建者模式：把对象的创建细节隐藏，使使用者直接调用方法即可拿到对象

3. 使用工厂生产SqlSession对象
   - 使用工厂模式生产session：解耦，降低类之间的依赖关系

4. 使用SqlSession创建Dao接口的代理对象
   - 使用了代理模式：不修改源码的基础上增强已有方法



### 2.2 QuickStart-注解配置
- Dao接口使用注解配置
~~~java
public interface IUserDao {
    @Seleect("select * from user")
    List<User> findAll();
}
~~~

- 移除mapper的配置文件IUserDao.xml，对mybatis主配置文件进行修改
~~~xml
...
  <configuration>
    ...

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao接口的全限定类名
    -->
    <mappers>
        <!-- <mapper resource="com/jj/dao/IUserDao.xml"/> -->
        <mapper class="com.jj.dao.IUserDao"/>
    </mappers>
  </configuration>
~~~

### 2.3 自定义MyBatis

![配置文件详解](https://s1.ax1x.com/2020/09/24/wzMseA.png)
![步骤](https://s1.ax1x.com/2020/09/24/0pn8d1.png)
- 读取配置信息到Configuration类，使用Mapper存储sql语句和结果类型
~~~java
/**
 * 自定义mybatis的配置类
 */
public class Configuration {
    private String driver;
    private String url;
    private String username;
    private String password;
    private Map<String, Mapper> mappers = new HashMap<String, Mapper>();
    ...
}

/**
 * 用于封装执行的sql语句和结果类型的全限定类名
 */
public class Mapper {
    public String queryString;  //sql
    public String resultType;   //实体类的全限定类名
~~~ 

- 创建获取SqlSession对象的工厂
~~~java
public class SqlSessionFactoryBuilder {
    public SqlSessionFactory build(InputStream inputStream){
        Configuration config = XMLConfigBuilder.loadConfiguration(inputStream);
        return new DefaultSqlSessionFactory(config);
    }
}
~~~
~~~java
public class DefaultSqlSessionFactory implements SqlSessionFactory {
    private Configuration config;
    public DefaultSqlSessionFactory(Configuration config){
        this.config = config;
    }

    public SqlSession openSession() {
        return new DefaultSqlSession(config);
    }
}
~~~

- SqlSession执行功能
~~~java
public class DefaultSqlSession implements SqlSession {
    private Configuration cfg;
    private Connection conn;    //数据库连接对象

    public DefaultSqlSession(Configuration cfg){
        this.cfg = cfg;
        conn = DataSourceUtil.getConnection(cfg);
    }

    public <T> T getMapper(Class<T> daoInterfaceClass) {  //使用代理对象完成功能
        return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]{daoInterfaceClass}, new MapperProxy(cfg.getMappers(), conn));
    }

    public void close() {
        if (conn!=null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
~~~

- MapperProxy代理对象

~~~java
public class MapperProxy implements InvocationHandler {
    private final Map<String, Mapper> mappers;
    private Connection conn;

    public MapperProxy(Map<String, Mapper> mappers, Connection conn) {
        this.mappers = mappers;
        this.conn = conn;
    }
    /**
     *调用selectList
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //1. 获取方法名
        String methodName = method.getName();
        //2. 获取方法所在类名
        String className = method.getDeclaringClass().getName();
        //3. 组合key
        String key = className+"."+methodName;
        //4. 获取key对应的mapper
        Mapper mapper = mappers.get(key);
        //5. 判断是否存在
        if(mapper==null){
            throw new IllegalArgumentException("传入的参数有误");
        }
        //6. 调用工具类执行查询所有
        return new Executor().selectList(mapper, conn);
    }
}
~~~

- 使用注解的方式

~~~java
/**
 * 查询的注解
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Select {
    String value();
}
~~~

## 3. mybatis的CRUD 
- 模糊查询 `select * from user where username like #{name}` 使用的是preparedStatement的方式`?`
- 模糊查询 `select * from user where username like '%${value}%'` 使用的是字符串拼接的Statement
- 保存用户后获取保存的用户的id: `select last_insert_id();`
~~~xml
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
~~~
- **OGNL表达式：** Object Graphic Navigation Language 对象图导航语言，**通过对象的取值方法来获取数据**，把get给省略了，而parameterType中已经提供了属性所属的类，所以直接写属性名即可  
~~~java
user.getUsername();   //类中的写法
user.username         //OGNL表达式
~~~
~~~xml
    <!-- parameterType已提供类名，所以查询语句里面只需要写属性名即可 -->
    <select id="findById" parameterType="INT" resultMap="userMap">   
        select * from user where id = #{uid}
    </select>
~~~

- **如果类的属性名和数据库的列名不匹配：** 
  - 查询时起别名：`select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;`
  - 或者配置查询结果的列名和实体类属性名的对应关系，并配置查询的reusltMap
  ~~~xml
    <!-- 配置 查询结果的列名和实体类的属性名的对应关系 -->
    <resultMap id="userMap" type="uSeR">
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthday"></result>
    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        select * from user;
    </select>
  ~~~

- CRUD
~~~xml
    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        <!--select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;-->
        select * from user;
    </select>

    <!-- 保存用户 -->
    <insert id="saveUser" parameterType="user">
        <!-- 配置插入操作后，获取插入数据的id -->
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
        insert into user(username,address,sex,birthday)values(#{userName},#{userAddress},#{userSex},#{userBirthday});
    </insert>

    <!-- 更新用户 -->
    <update id="updateUser" parameterType="USER">
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId}
    </update>

    <!-- 删除用户-->
    <delete id="deleteUser" parameterType="java.lang.Integer">
        delete from user where id = #{uid}
    </delete>
    
    <!-- 根据id查询用户 -->
    <select id="findById" parameterType="INT" resultMap="userMap">
        select * from user where id = #{uid}
    </select>

    <!-- 根据名称模糊查询 -->
    <select id="findByName" parameterType="string" resultMap="userMap">
          select * from user where username like #{name}
        <!-- select * from user where username like '%${value}%'-->
   </select>

    <!-- 获取用户的总记录条数 -->
    <select id="findTotal" resultType="int">
        select count(id) from user;
    </select>

    <!-- OGNL应用：根据queryVo的条件查询用户(QueryVo中有User的对象)，实现多对象查询 -->
    <select id="findUserByVo" parameterType="com.itheima.domain.QueryVo" resultMap="userMap">
        select * from user where username like #{user.username}
    </select>
~~~
- 测试
~~~java
    @Before//用于在测试方法执行之前执行
    public void init()throws Exception{
        //1.读取配置文件，生成字节输入流
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.获取SqlSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.获取SqlSession对象
        sqlSession = factory.openSession();
        //4.获取dao的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception{
        //****************************************提交事务
        sqlSession.commit();
        //6.释放资源
        sqlSession.close();
        in.close();
    }

    @Test
    ...
~~~
## 4. 主配置文件中的其他配置
数据库配置可以外置：

对于SqlMapConfig.xml，可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息
~~~xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mydb
jdbc.username=root
jdbc.password=root
~~~
- resource属性：用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。
- url属性：是要求按照Url的写法来写地址(协议 主机 端口 URI)  http://localhost:8080/mybatisserver/demo1Servlet ，本地文件用的是file协议，端口默认：file:///+绝对路径
~~~xml
<configuration>
    <!--使用resource属性配置-->
    <properties resource="jdbcConfig.properties">
    </properties>

    <!--配置环境-->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务 -->
            <transactionManager type="JDBC"></transactionManager>

            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
        </environment>
    </environments>
</configuration>
~~~
~~~xml
    <!--使用url属性配置-->
    <properties url="file:///D:/Java/05-Mybatis/.../src/main/resources/jdbcConfig.properties">
    </properties>
~~~

- 可以使用typeAliases配置别名(只能配置domain中的类的别名)
~~~xml
<typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>
~~~
- 也可以**用package属性指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写**
~~~xml
<package name="com.itheima.domain"></package>
~~~

- Mappers还可以直接用package配置，指定dao接口所在的包，指定了之后就不需要再写mapper resource/class 了
~~~xml
    <mappers>
        <!--<mapper resource="com/itheima/dao/IUserDao.xml"></mapper>-->
        <!--<mapper class="com.itheima.dao.IUserDao"/>-->
        <package name="com.itheima.dao"></package>
    </mappers>
~~~











# Spring
解耦，简化开发；AOP编程，实现传统OOP不易实现的功能；声明式事务的支持；方便测试；方便对各种优秀框架的支持(Structs,Hibernate,Hessian等)；降低JavaEE API的使用难度，如JDBC、JavaMail等；源码是经典的学习范例

## 1. Spring 简介入门

### 1.1 Spring概览
Spring体系结构
![Spring体系结构](https://s1.ax1x.com/2020/09/14/wDMp8S.gif)

Spring开发步骤
![wDMqRU.png](https://s1.ax1x.com/2020/09/14/wDMqRU.png)
1. 导入Spring开发的基本包坐标
2. 编写Dao接口和实现类
3. 创建Spring核心配置文件
4. 在Spring配置文件中配置UserDaoImpl
5. 使用Spring的API获得Bean实例
### 1.2 QuickStart
