# Maven
- 依赖管理：
- 项目的一键构建：编译、测试、运行、打包、安装、部署 整个过程都交给maven来进行管理。

## 1. 基础知识
安装配置全过程见：https://blog.csdn.net/a805814077/article/details/100545928
- 环境变量中添加 MAVEN_HOME=D:\Program Files\apache-maven-3.6.3
- Path 中添加 %MAVEN_HOME%\bin
- 默认本地仓库位置：`Default: ${user.home}/.m2/repository`，本地仓库没有时去中央仓库寻找
![wDcPtP.png](https://s1.ax1x.com/2020/09/14/wDcPtP.png)

- 修改本地仓库：`<localRepository>D:\maven_repository</localRepository>`
- maven项目结构：核心代码、配置文件、测试代码、测试配置文件
- 标准目录结构
  - `src/main/java` : 核心代码
  - `src/main/resources` : 配置文件
  - `src/test/java` : 测试代码
  - `src/test/resources` : 测试配置文件
  - `src/main/webapp` : 页面资源，js，css，图片等
## 2. 常用命令
- `mvn compile` : 编译src/main 放置在target中
- `mvn clean` : 清除本地编译信息，删除target目录
- `mvn test` : 编译**src/test和src/main**
- `mvn package` : 打包项目成.var(根据pom中`<packaging>war</packaging>`)，放置在target目录中
- `mvn install` : 将改项目编译，打包，并安装到本地仓库
- 整个项目构建过程：**清除项目编译信息(clean)、编译(compile)、测试(test)、打包(package)、安装(insatall)、发布(deploy)** 均有对应命令
- 生命周期：清理生命周期(clean)、**默认生命周期(compile->deploy)**、站点生命周期

## 3. maven 概念模型
![wDfGwQ.png](https://s1.ax1x.com/2020/09/14/wDfGwQ.png)

## 4. maven 的一些配置

- IDEA maven配置：Maven->Runner->VM Options:`-DarchetypeCatalog=internal`
- maven换源：推荐第一个

~~~xml
 <!-- 阿里云仓库 -->
        <mirror>
            <id>alimaven</id>
            <mirrorOf>central</mirrorOf>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
        </mirror>
     或者
      <mirror>
		<id>nexus-aliyun</id>
		<mirrorOf>*</mirrorOf>
        <name>Nexus aliyun</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
	 </mirror>
~~~
- 坑：`java: 程序包org.springframework.boot不存在` 新版IDEA需要在Setting里将 delegate IDE build/run actions to Maven勾选上即可
- 使用骨架创建web工程：Maven->Create from archtype->maven-archetype-webapp
- **jdk1.8以上需要运行tomcat7以上版本！！！！(默认是6)** ， 使用 `mvn tomcat7:run` 运行
~~~xml
        <plugin>
          <groupId>org.apache.tomcat.maven</groupId>
          <artifactId>tomcat7-maven-plugin</artifactId>
          <version>2.2</version>
          <configuration>
            <uriEncoding>UTF-8</uriEncoding>
            <path>/</path>
            <port>8080</port>
          </configuration>
        </plugin>
~~~
- **jar包冲突**：tomcat中有servlet和servlet.jsp包，所以冲突，解决办法：设置scope作用范围为 `provided`

~~~xml
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>
~~~
- **最后记得配置web.xml中的servlet映射：**

~~~xml
  <servlet>
    <servlet-name>MyServlet</servlet-name>
    <servlet-class>com.jj.servlet.MyServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>MyServlet</servlet-name>
    <url-pattern>/MyServlet</url-pattern>
  </servlet-mapping>
~~~

## 5. 常见的scope作用域例子

| 依赖范围     | 编译classpath有效 | 测试classpath有效 | 运行时classpath有效 | 例子                                                           |
| ------------ | :---------------: | :---------------: | :-----------------: | -------------------------------------------------------------- |
| compile      |         Y         |         Y         |          Y          | spring-core                                                    |
| test         |         -         |         Y         |          -          | Junit                                                          |
| **provided** |         Y         |         Y         |          -          | **servlet-api**                                                |
| **runtime**  |         -         |         Y         |          Y          | **JDBC驱动**                                                   |
| system       |         Y         |         Y         |          -          | 本地的，Maven仓库之外的类库<br>显示提供本地jar路径，一般不使用 |

# MVC 和 三层架构
## MVC
Model View Controllor(模型，视图和控制器)，是一种软件的开发模式(不是设计模式)      

- **视图(View)：** 展示数据，与用户直接进行交互【JSP】
- **模型(Model)：** 完成具体的业务操作(查询数据库，封装对象)【JavaBean】
- **控制器(Controllor)：** 获取用户输入，调用相应的模型处理，将模型处理的结果交给视图展示【Servlet】 

**优点：** 低耦合，方便维护，有利于分工合作，重用性高           
**缺点：** 项目架构变得复杂         

## 三层架构  
软件设计架构            
- 视图层、界面层(View层/web层)：接收用户请求，用户可以通过界面上的组件和服务器进行交互
- 服务层、业务逻辑层(Service层)：系统的业务逻辑      
- 持久层、数据访问层(Dao层)：直接操作数据库      

![三层架构.png](https://s1.ax1x.com/2020/08/20/d3j1BD.png)

为了更好的降低各层间的耦合度，在三层架构程序设计中，采用**面向抽象编程**。即上层对下层的调用，是通过**接口**实现的。而下层对上层的真正服务提供者，是下层**接口的实现类**        

## MVC与三层架构的关系
三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层
![MVC和三层架构的关系.png](https://s1.ax1x.com/2020/08/20/d3LGAs.png)

## 三层架构和各个框架的关系
![wXPDB9.png](https://s1.ax1x.com/2020/09/22/wXPDB9.png)

# MyBatis
- **mybatis** 是优秀的java**持久层框架**，内部**封装了jdbc操作的很多细节**，开发者只需要关注sql本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，它使用**ORM(Object Realtional Mapping 对象关系映射)** 思想实现了结果集的封装。
- **Hibernate** 也是持久层的一个解决方案
 
## 1. 原始jdbc存在的问题
- 数据库连接创建、释放频繁造成系统资源浪费影响系统性能------使用数据库连接池
- sql语句硬编码，不易维护，变动需要改变java代码------将sql语句抽取到xml配置文件中
- 查询结果需要手动封装到实体中，插入操作需要手动将实体数据设置到sql语句的占位------利用反射、内省等底层技术实现实体属性和表字段的映射

## 2. QuickStart 和 自定义mybatis功能
### 2.1 QuickStart-xml配置
1. 添加MyBatis的坐标
2. 创建user数据表
3. 创建实体类和Dao接口
4. 创建映射配置文件 IUserDao.xml
5. 创建mybatis主配置文件 SqlMapConfig.xml
6. 测试

**注意：**
1. 在Mybatis中，持久层的操作接口名称和映射文件也叫**Mapper**： IUserDao.xml  也写作 IUserMapper.xml
2. idea中创建目录的时候和包不同，包在创建com.jj.dao是三级结构，但是创建目录是一级结构：IUserDao.xml的目录**必须一级一级的创建**
3. mybatis的映射配置文件结构必须要和dao接口的包接口相同： `main/java/com/jj/dao/IUserDao`  和  `resources/com/jj/dao/IUserDao.xml`  必须一一对应
4. 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名
5. 映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名

遵守345规则之后，开发中无需再写dao的实现类了！
- **核心配置文件：sqlMapConfig.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
 <!-- mybatis的主配置文件 -->
<configuration>
    <!-- 配置环境 -->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!-- 配置数据源（连接池） -->
            <dataSource type="POOLED">
                <!-- 配置连接数据库的4个基本信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
                <property name="username" value="root"/>
                <property name="password" value="janshan123"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao的全限定类名
    -->
    <mappers>
        <mapper resource="com/jj/dao/IUserDao.xml"/>
        <!-- <mapper class="com.jj.dao.IUserDao"/> -->
    </mappers>
</configuration>
~~~
- **Mapper的配置：IUserDao.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jj.dao.IUserDao">
    <!--配置查询所有-->
    <select id="findAll" resultType="com.jj.domain.User">
        select * from user
    </select>
</mapper>
~~~

- 测试步骤如下：
~~~java
    public void test1() throws IOException {
        //1. 加载核心配置文件
        InputStream inputStream = Resources.getResourceAsStream("sqlMapConfig.xml");
        
        //2. 创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(inputStream);
        
        //3. 使用工厂生产SqlSession对象
        SqlSession session = factory.openSession();
        
        //4. 使用SqlSession创建Dao接口的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        
        //5. 使用代理对象执行Dao中的方法
        List<User> users = userDao.findAll();
        for(User user: users){
            System.out.println(user);
        }
        
        //6. 释放资源
        session.close();
        inputStream.close();
    }
~~~

#### 2.1.1 测试步骤详解
1. 加载核心配置文件
   - 使用绝对路径的写法不具有通用性，而相对路径写法在部署后src目录也没了，也不适用。均不使用
   - **使用类加载器：** 只能读取类路径的配置文件
   - **使用ServletContext对象的getRealPath()** 

2. 创建SqlSessionFactory工厂
   - 创建工厂时，mybatis使用了构建者模式：把对象的创建细节隐藏，使使用者直接调用方法即可拿到对象

3. 使用工厂生产SqlSession对象
   - 使用工厂模式生产session：解耦，降低类之间的依赖关系

4. 使用SqlSession创建Dao接口的代理对象
   - 使用了代理模式：不修改源码的基础上增强已有方法



### 2.2 QuickStart-注解配置
- Dao接口使用注解配置
~~~java
public interface IUserDao {
    @Seleect("select * from user")
    List<User> findAll();
}
~~~

- 移除mapper的配置文件IUserDao.xml，对mybatis主配置文件进行修改
~~~xml
...
  <configuration>
    ...

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao接口的全限定类名
    -->
    <mappers>
        <!-- <mapper resource="com/jj/dao/IUserDao.xml"/> -->
        <mapper class="com.jj.dao.IUserDao"/>
    </mappers>
  </configuration>
~~~

### 2.3 自定义MyBatis

![配置文件详解](https://s1.ax1x.com/2020/09/24/wzMseA.png)
![步骤](https://s1.ax1x.com/2020/09/24/0pn8d1.png)
- 读取配置信息到Configuration类，使用Mapper存储sql语句和结果类型
~~~java
/**
 * 自定义mybatis的配置类
 */
public class Configuration {
    private String driver;
    private String url;
    private String username;
    private String password;
    private Map<String, Mapper> mappers = new HashMap<String, Mapper>();
    ...
}

/**
 * 用于封装执行的sql语句和结果类型的全限定类名
 */
public class Mapper {
    public String queryString;  //sql
    public String resultType;   //实体类的全限定类名
~~~ 

- 创建获取SqlSession对象的工厂
~~~java
public class SqlSessionFactoryBuilder {
    public SqlSessionFactory build(InputStream inputStream){
        Configuration config = XMLConfigBuilder.loadConfiguration(inputStream);
        return new DefaultSqlSessionFactory(config);
    }
}
~~~
~~~java
public class DefaultSqlSessionFactory implements SqlSessionFactory {
    private Configuration config;
    public DefaultSqlSessionFactory(Configuration config){
        this.config = config;
    }

    public SqlSession openSession() {
        return new DefaultSqlSession(config);
    }
}
~~~

- SqlSession执行功能
~~~java
public class DefaultSqlSession implements SqlSession {
    private Configuration cfg;
    private Connection conn;    //数据库连接对象

    public DefaultSqlSession(Configuration cfg){
        this.cfg = cfg;
        conn = DataSourceUtil.getConnection(cfg);
    }

    public <T> T getMapper(Class<T> daoInterfaceClass) {  //使用代理对象完成功能
        return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]{daoInterfaceClass}, new MapperProxy(cfg.getMappers(), conn));
    }

    public void close() {
        if (conn!=null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
~~~

- MapperProxy代理对象

~~~java
public class MapperProxy implements InvocationHandler {
    private final Map<String, Mapper> mappers;
    private Connection conn;

    public MapperProxy(Map<String, Mapper> mappers, Connection conn) {
        this.mappers = mappers;
        this.conn = conn;
    }
    /**
     *调用selectList
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //1. 获取方法名
        String methodName = method.getName();
        //2. 获取方法所在类名
        String className = method.getDeclaringClass().getName();
        //3. 组合key
        String key = className+"."+methodName;
        //4. 获取key对应的mapper
        Mapper mapper = mappers.get(key);
        //5. 判断是否存在
        if(mapper==null){
            throw new IllegalArgumentException("传入的参数有误");
        }
        //6. 调用工具类执行查询所有
        return new Executor().selectList(mapper, conn);
    }
}
~~~

- 使用注解的方式

~~~java
/**
 * 查询的注解
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Select {
    String value();
}
~~~

## 3. mybatis的CRUD 
- 模糊查询 `select * from user where username like #{name}` 使用的是preparedStatement的参数占位符方式`?`
- 模糊查询 `select * from user where username like '%${value}%'` 使用的是字符串拼接的Statement
- 保存用户后获取保存的用户的id: `select last_insert_id();`
~~~xml
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
~~~
- **OGNL表达式：** Object Graphic Navigation Language 对象图导航语言，**通过对象的取值方法来获取数据**，把get给省略了，而parameterType中已经提供了属性所属的类，所以直接写属性名即可  
~~~java
user.getUsername();   //类中的写法
user.username         //OGNL表达式
~~~
~~~xml
    <!-- parameterType已提供类名，所以查询语句里面只需要写属性名即可 -->
    <select id="findById" parameterType="INT" resultMap="userMap">   
        select * from user where id = #{uid}
    </select>
~~~

- **如果类的属性名和数据库的列名不匹配：** 
  - 查询时起别名：`select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;`
  - 或者配置查询结果的列名和实体类属性名的对应关系，并配置查询的reusltMap
  ~~~xml
    <!-- 配置 查询结果的列名和实体类的属性名的对应关系 -->
    <resultMap id="userMap" type="uSeR">
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthday"></result>
    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        select * from user;
    </select>
  ~~~

- CRUD
~~~xml
    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        <!--select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;-->
        select * from user;
    </select>

    <!-- 保存用户 -->
    <insert id="saveUser" parameterType="user">
        <!-- 配置插入操作后，获取插入数据的id -->
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
        insert into user(username,address,sex,birthday)values(#{userName},#{userAddress},#{userSex},#{userBirthday});
    </insert>

    <!-- 更新用户 -->
    <update id="updateUser" parameterType="USER">
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId}
    </update>

    <!-- 删除用户-->
    <delete id="deleteUser" parameterType="java.lang.Integer">
        delete from user where id = #{uid}
    </delete>
    
    <!-- 根据id查询用户 -->
    <select id="findById" parameterType="INT" resultMap="userMap">
        select * from user where id = #{uid}
    </select>

    <!-- 根据名称模糊查询 -->
    <select id="findByName" parameterType="string" resultMap="userMap">
          select * from user where username like #{name}
        <!-- select * from user where username like '%${value}%'-->
   </select>

    <!-- 获取用户的总记录条数 -->
    <select id="findTotal" resultType="int">
        select count(id) from user;
    </select>

    <!-- OGNL应用：根据queryVo的条件查询用户(QueryVo中有User的对象)，实现多对象查询 -->
    <select id="findUserByVo" parameterType="com.jj.domain.QueryVo" resultMap="userMap">
        select * from user where username like #{user.username}
    </select>
~~~
- 测试
~~~java
    @Before//用于在测试方法执行之前执行
    public void init()throws Exception{
        //1.读取配置文件，生成字节输入流
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.获取SqlSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.获取SqlSession对象
        sqlSession = factory.openSession();
        //4.获取dao的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception{
        //****************************************提交事务
        sqlSession.commit();
        //6.释放资源
        sqlSession.close();
        in.close();
    }

    @Test
    ...
~~~
## 4. 主配置文件中的其他配置
数据库配置可以外置：

对于SqlMapConfig.xml，可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息
~~~xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mydb
jdbc.username=root
jdbc.password=root
~~~
- resource属性：用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。
- url属性：是要求按照Url的写法来写地址(协议 主机 端口 URI)  http://localhost:8080/mybatisserver/demo1Servlet ，本地文件用的是file协议，端口默认：file:///+绝对路径
~~~xml
<configuration>
    <!--使用resource属性配置-->
    <properties resource="jdbcConfig.properties">
    </properties>

    <!--配置环境-->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务 -->
            <transactionManager type="JDBC"></transactionManager>

            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
        </environment>
    </environments>
</configuration>
~~~
~~~xml
    <!--使用url属性配置-->
    <properties url="file:///D:/Java/05-Mybatis/.../src/main/resources/jdbcConfig.properties">
    </properties>
~~~

- 可以使用typeAliases配置别名(只能配置domain中的类的别名)
~~~xml
<typeAlias type="com.jj.domain.User" alias="user"></typeAlias>
~~~
- 也可以**用package属性指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写！！！！**
~~~xml
<package name="com.jj.domain"></package>
~~~

- **Mappers还可以直接用package配置，指定dao接口所在的包，指定了之后就不需要再写mapper resource/class 了！！！！**
~~~xml
    <mappers>
        <!--<mapper resource="com/jj/dao/IUserDao.xml"></mapper>-->
        <!--<mapper class="com.jj.dao.IUserDao"/>-->
        <package name="com.jj.dao"></package>
    </mappers>
~~~

## 5. 连接池
- 连接池可以减少获取连接所消耗的时间，经常应用到实际开发中
- 连接池就是一个集合对象(容器)，该集合必须是**线程安全**的，两个线程不能获取到同一个连接，同时还要实现**队列**的特性

### 5.1 连接池的配置
在主配置文件中 `SqlMapConfig.xml` 中的`dataSource`标签，type属性表示使用哪种连接池
~~~xml
            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
~~~
- `POOLED`：采用传统的`javax.sql.DataSource` 规范的连接池，mybatis针对该规范进行实现
- `UNPOOLED`：采用传统的获取连接的方式，虽然也实现了`javax.sql.DataSource`接口，但是**没有使用池思想** 
- `JNDI`：采用服务器提供的`JNDI`技术实现，来获取`DataSource`对象，不同服务器拿到的DataSource不同(只有web或maven的war工程才能使用)

### 5.2 POOLED
![POOLED](https://s1.ax1x.com/2020/09/24/0pN5gs.png)
- mybatis内部定义了实现java.sql.DataSource接口的 `PooledDataSource` 类来表示POOLED类型的数据源
![POOLED.jpg](https://s1.ax1x.com/2020/09/24/0pUqsI.jpg)
- 空闲池还有连接直接拿来用，否则去看活动池是否达到最大数量，未达到则创建新的连接，达到了就获取活动连接池最老的一个连接
### 5.3 UNPOOLED
![UNPOOLED](https://s1.ax1x.com/2020/09/24/0pN43j.png)
- mybatis内部定义了实现java.sql.DataSource接口的 `UnpooledDataSource` 类来表示UMPOOLED类型的数据源

### 5.3 JNDI
- 模拟的是windows的注册表
- key：路径+名称(路径固定，name可以指定)  value：数据(JNDI中就是存的对象)



## 6. 事务控制
- 什么是事务？四大特性ACID？不考虑隔离性会产生的3个问题？四种隔离级别？
- 通过`sqlSession` 对象的`commit`方法和`rollback`方法来实现事务的提交和回滚
- **默认是手动提交**，可以设置为自动提交：`sqlSession = factory.openSession(true)`

## 7. 动态sql语句(XML配置)
- 可以使用 `if` 、 `where` 、`foreach` 标签

### 7.1 if 标签
- 使用 `test` 属性来进行条件的判断，注意改造原本的sql语句：加上 `where 1=1`
~~~java
//根据条件查询，可能有用户名，可能有性别，可能有地址
List<User> findUserByCondition(User user);
~~~
~~~xml
<!--使用条件查询-->
<select id="findUserByCondition" resultMap="userMap">
    select * from user where 1=1
    <if test="username!=null">
      and username=#{username}
    </if>
    <if test="sex!=null">
      and sex=#{sex}
    </if>
    <if test="address!=null">
      and address=#{address}
    </if>
</select>
~~~

### 7.2 where 标签
- 使用where标签套if标签，无需改造无条件的sql语句，使得原本的sql语句更简洁
~~~xml
<!--使用条件查询-->
<select id="findUserByCondition" resultMap="userMap">
    select * from user
    <where>
        <if test="username!=null">
          and username=#{username}
        </if>
        <if test="sex!=null">
          and sex=#{sex}
        </if>
        <if test="address!=null">
          and address=#{address}
        </if>
    <where>
</select>
~~~

### 7.3 foreach 标签
- 使用foreach标签实现范围查询
~~~xml
<select id="findUserInIds" parameterType="queryvo" resultMap="userMap">
    select * from user
    <where>
        <if test="ids!=null and ids.size>0">
            <foreach collection="ids" open="and id in(" close=")" item="id" separator=",">
                #{id}
            </foreach>
        </if>
    <where>
</select>
~~~

## 8. 多表查询
https://blog.csdn.net/qq_34332010/article/details/77284744  

查询方法
- 新建一个domain的实体类，将需要的多表联合信息封装进实体类(不常用)
- 使用collection 和 association 建立主表和从表之间的关系

一般使用第二种方法
- 关联 - association 【多对一】
- 集合 - collection 【一对多】


下面是用户表和账户表，一个用户可以有多个账户
| id  | username | birthday            | sex | address    |
| --- | -------- | ------------------- | --- | ---------- |
| 41  | 老王     | 2018-02-27 17:47:08 | 男  | 北京       |
| 45  | 老李     | 2018-03-04 12:04:06 | 男  | 上海       |
| 46  | 老王     | 2018-03-07 17:37:26 | 女  | 深圳       |

|    ID  |   UID |   money
|------  |------ | --------
|     1  |    41 |     10000
|     2  |    45 |     20000
|     3  |    41 |     30000
- domain实体类
~~~java
public class User implements Serializable {

    private Integer id;
    private String username;
    private String address;
    private String sex;
    private Date birthday;

    private List<Account> accounts;   //一对多关系映射：主表实体应该包含从表实体的集合引用
    ...
}

public class Account implements Serializable {

    private Integer id;
    private Integer uid;
    private Double money;
    
    private User user;          //多对一关系：从表实体应该包含一个主表实体的对象引用
    ...
}
~~~
- dao层
~~~java
public Interface IUserDao{
  User findAllUsersWithAccountInfo();
  ...
}

public Interface IAccountDao{
  WorkExp findAllAccountsWithUserInfo();
  ...
}
~~~

- **多对一(一对一)：mapper中 使用association建立联系，javaType表示子结果封装的类型**
~~~xml
<mapper namespace="com.jj.dao.IAccountDao">

    <!-- 定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="aid"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 多对一的关系映射：配置封装user的内容-->
        <association property="user" column="uid" javaType="user">
            <id property="id" column="id"></id>
            <result property="username" column="username"></result>
            <result property="address" column="address"></result>
            <result property="sex" column="sex"></result>
            <result property="birthday" column="birthday"></result>
        </association>
    </resultMap>

    <!-- 查询所有账户信息并附带其归属用户信息 -->
    <select id="findAllAccountsWithUserInfo" resultMap="accountUserMap">
        select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid;
    </select>
</mapper>
~~~

- **一对多：mapper中 使用collection建立联系，ofType表示结果集元素的封装类型**
~~~xml
<mapper namespace="com.jj.dao.IUserDao">

    <!-- 定义User的resultMap-->
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!-- 配置user对象中accounts集合的映射 -->
        <collection property="accounts" ofType="account">
            <id property="id" column="aid"></id>
            <result property="uid" column="uid"></result>
            <result property="money" column="money"></result>
        </collection>
    </resultMap>

    <!-- 查询所有用户信息并附带其账户信息 -->
    <select id="findAllUsersWithAccountInfo" resultMap="userAccountMap">
        select u.*, a.id as aid, a.uid, a.money from user u left outer join account a on u.id = a.uid
    </select>
</mapper>
~~~

 - 多对多：两个实体都包含另一实体的集合引用，查询时需要借助中间表

## 9. MyBatis延迟加载
- 延迟加载(按需加载、懒加载)：需要使用数据时才发起查询，不用的数据不查询
- 立即加载：不管用不用，只要调用方法，马上发起查询

对于一对多或者多对多的情况，通常采用延迟加载                
对于一对一或者多对一的情况，通常采用立即加载

### 9.1 association，多对一延迟加载
- 主配置文件中开启延迟加载: `lazyLoadingEnabled`-> true，`aggressiveLazyLoading`-> false
~~~xml
<configuration>
    <!-- 配置properties-->
    <properties resource="jdbcConfig.properties"></properties>
    <settings>
        <!--打开延迟加载总开关-->
        <setting name="lazyLoadingEnabled" value="true"/>
        <!--将积极加载改为消息加载，即按需加载-->
        <setting name="aggressiveLazyLoading" value="false"/>
    </settings>
    ...
</configuration>
~~~

- Account的mapper中配置
~~~xml
<mapper namespace="com.jj.dao.IAccountDao">

    <!-- 定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="id"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>

        <!-- 一对一的关系映射：配置封装user的内容
             select属性指定查询用户的唯一标识
             column属性指定用户根据id查询时所需要的参数值 -->
        <association property="user" column="uid" javaType="user" select="com.jj.dao.IUserDao.findUserById">
        </association>

    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="accountUserMap">
        select * from account
    </select>

    <!--根据uid查询到账户-->
    <select id="findAccountByUid" parameterType="INT" resultType="account">
        select * from account where uid=#{uid};
    </select>

</mapper>
~~~

### 9.2 collection，一对多延迟加载
- 主配置文件开启延迟加载
- User 的mapper中的配置
~~~xml
<mapper namespace="com.jj.dao.IUserDao">

    <!-- 定义User的resultMap-->
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>

        <!-- 配置user对象中accounts集合的映射 -->
        <collection property="accounts" ofType="account" column="id" select="com.jj.dao.IAccountDao.findAccountByUid">
        </collection>

    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="userAccountMap">
        select * from user
    </select>

    <!-- 根据id查询用户 -->
    <select id="findUserById" parameterType="INT" resultType="user">
        select * from user where id = #{id}
    </select>

</mapper>
~~~


## 10. MyBatis缓存

- 缓存可以减少和数据库的数据交换次数，提高执行效率
- **经常查询，不经常改变，并且数据的正确与否对最终结果影响不大**的数据才适合存放在缓存中
- MyBatis中有一级缓存和二级缓存
### 10.1 一级缓存
- MyBatis中的一级缓存指的是**SqlSession对象的缓存** 
- 当执行查询之后，查询的结果会同时存入到由 SqlSession 提供的一块内存区域中，该区域的结构是 **Map** 
- 当再次查询相同数据时，mybatis就会先去SqlSession中查询是否存在缓存，存在则直接拿来用
- 当**SqlSession对象消失时**，mybatis的一级缓存就消失了，还可以调用`sqlSession.clearCache()`来主动清空缓存
- 另外，当调用SqlSession的 **修改，添加，删除，commit()，close()** 等方法时，都将清空一级缓存
- 一级缓存直接**存放的是对象**，缓存存在时，**两次查询到的对象就是同一个对象**
### 10.2 二级缓存
- MyBatis中的二级缓存指的是 **SqlSessionFactory对象的缓存**， 由同一个 SqlSessionFactory 生产的  SqlSession 共享这一块二级缓存
- 二级缓存的生效需要对**MyBatis**的 `SqlMapConfig.xml` 和当前的 **映射文件** `Dao.xml` ，以及当前 **操作的select标签** 进行配置
- 二级缓存中**存放的是数据**，而不是对象，所以两次查询虽然使用了缓存，但是需要根据数据创建对象，所以**查询到的对象并不是同一个对象**
~~~xml
SqlMapConfig.xml中：
    <settings>
        <!--配置二级缓存-->
        <setting name="cacheEnabled" value="true"/>
    </settings>
~~~
~~~xml
IUserDao.xml中开启二级缓存，以及对select标签进行配置：
<mapper namespace="com.jj.dao.IUserDao">
    <!--开启user支持二级缓存-->
    <cache/>

    <!-- 根据id查询用户 -->
    <select id="findUserById" parameterType="INT" resultType="user" useCache="true">
        select * from user where id = #{id}
    </select>
</mapper>
~~~


## 11. 注解开发
![注解和xml的对应](https://s1.ax1x.com/2020/09/25/0C2oEF.png)
- MyBatis中针对CRUD一共由四种注解：**@Select、@Insert、@Update、@Delete**
- 使用注解开发时，不能再有 mapper 的xml配置文件，会报错
### 11.1 主配置文件的配置
- 配置实体类的别名，在从列到属性到对象的映射时才能找到相应的对象。直接配置为实体的包，之后所有的实体类的别名就是类名
- mappers使用 package 配置，直接配置到dao的包，以免每个dao都需要配置mapper
~~~xml
<configuration>
    <!--引入外部配置文件-->
    <properties resource="jdbcConfig.properties"></properties>

    <!--配置别名-->
    <typeAliases>
        <package name="com.jj.domain"/>
    </typeAliases>

    <!--配置环境-->
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!--指定映射的配置-->
    <mappers>
        <package name="com.jj.dao"/>
    </mappers>
</configuration>
~~~

### 11.2 关于模糊查询
注意两种模糊查询的方式
~~~java
//Dao：底层使用的是preparedStatement的参数占位符方式`?`
@Select("select * from user where username like #{username}")
List<User> findUserByName(String name);

//测试
List<User> users = userDao.findUserByName("%王%");
~~~

~~~java
//Dao：底层使用的是Statement方式的字符串拼接
@Select("select * from user where username like '%${value}%'")
List<User> findUserByName(String name);

//测试
List<User> users = userDao.findUserByName("王");
~~~

### 11.3 数据库字段到实体属性的映射

- 对于实体属性和数据库字段不对应的情况，mybatis提供了 `@Results` 字段的注解来配置映射
~~~java
//使用Results注解配置数据库字段到属性的映射
@Select("select * from user")
@Results( value={
    @Result(id=true, column="id", property="userId")
    @Result(column="username", property="userName")
    @Result(column="address", property="userAddress")
    @Result(column="sex", property="userSex")
    @Result(column="birthday", property="userBirthday")
})
List<User> findAll();
~~~

- 还可以给 `@Results` 提供唯一标识，之后使用 `@ResultMap` 通过value直接引用相应id的Results，避免每个查询都需要进行注解的属性和数据库字段映射配置，这也给多表查询提供了方法
~~~java
//Results注解，定义封装的映射userMap
@Select("select * from user")
@Results(id="userMap", value={
    @Result(id=true, column="id", property="userId")
    @Result(column="username", property="userName")
    @Result(column="address", property="userAddress")
    @Result(column="sex", property="userSex")
    @Result(column="birthday", property="userBirthday")
})
List<User> findAll();

//通过ResultMap的value字段直接使用之前定义的userMap
@Select("select * from user where username like #{username}")
@ResultMap(value={"userMap"})
List<User> findUserByName(String name);

//value字段也可以省略，而数组中只有一个元素，大括号也可以省略
@Select("select * from user where id=#{id}")
@ResultMap("userMap")
List<User> findUserById(int id);
~~~
### 11.4 注解实现多表查询
1. 多对一，一对一：     
通过`Result` 配置再映射         
`one`属性表示对一，`select`属性配置用于查询的Dao的方法，`fetchType`可以设置为立即加载
~~~java
public interface IAccountDao {
    @Select("select * from account")
    @Results(id="accountMap", value={
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "uid", property = "uid"),
            @Result(column = "money", property = "money"),
            @Result(column = "uid", property = "user",
                    one=@One(select="com.jj.dao.IUserDao.findById", 
                    fetchType= FetchType.EAGER))
    })
    List<Account> findAll();

    @Select("select * from account where uid = #{uid}")
    List<Account> findByUid(int uid);
}
~~~

2. 一对多： 
通过`Result` 配置再映射         
`many`属性表示对多，`select`属性配置用于查询的Dao的方法，`fetchType`可以设置为懒加载
~~~java
public interface IUserDao {
    @Select("select * from user")
    @Results(id="userMap", value={
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "username", property = "username"),
            @Result(column = "address", property = "address"),
            @Result(column = "sex", property = "sex"),
            @Result(column = "birthday", property = "birthday"),
            @Result(column = "id", property = "accounts",
                    many = @Many(select = "com.jj.dao.IAccountDao.findByUid", 
                    fetchType = FetchType.LAZY))
    })
    List<User> findAll();

    @Select("select * from user where id=#{id}")
    User findById(int id);
}
~~~ 
### 11.5 注解开启缓存
- 一级缓存`session`无需配置，可以直接使用
- 二级缓存`sessionFactory`需要配置以开启
首先需要在MyBatis的主配置文件 SqlMapConfig.xml 中配置开启缓存
~~~xml
    <settings>
        <!--配置二级缓存-->
        <setting name="cacheEnabled" value="true"/>
    </settings>
~~~

然后使用注解的方式对Dao配置`@CacheNameSpace`注解的`blocking`属性为true即可
~~~java
@CacheNamespace(blocking = true)
public interface IUserDao {
    ....
}
~~~

# Spring
解耦，简化开发；AOP 编程，实现传统OOP不易实现的功能；声明式事务的支持；方便测试；方便对各种优秀框架的支持(Structs,Hibernate,Hessian等)；降低JavaEE API的使用难度，如JDBC、JavaMail等；源码是经典的学习范例

## 1. Spring 简介入门

### 1.1 Spring概览
Spring体系结构
![Spring体系结构](、https://s1.ax1x.com/2020/09/14/wDMp8S.gif)

Spring开发步骤
![wDMqRU.png](、https://s1.ax1x.com/2020/09/14/wDMqRU.png)
1. 导入Spring开发的基本包坐标
2. 编写Dao接口和实现类
3. 创建Spring核心配置文件
4. 在Spring配置文件中配置UserDaoImpl
5. 使用Spring的API获得Bean实例
### 1.2 QuickStart
