# java基本数据结构的实现

## 1. 队列
<center>

![dohevd.png](https://s1.ax1x.com/2020/08/28/dohevd.png)
</center>

- 队列(queue)是一种常用的数据结构，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。
- Queue接口提供了添加元素操作`offer`、删除并返回第一个元素`poll`、返回第一个元素`peek`
- **注意：** `add`、`remove`、`element`也可以实现上述功能，但是对于空和满的状态**会抛出异常**，所以一般使用offer系列操作
~~~java
public interface Queue<E> extends Collection<E> {
    
    boolean add(E e);       //往队列插入元素，如果出现异常会抛出异常 
    E remove();             //移除队列元素，如果出现异常会抛出异常    
    E element();            //获取队列头部元素，如果出现异常会抛出异常

    boolean offer(E e);     //往队列插入元素，如果出现异常则返回false
    E poll();               //移除队列元素，如果出现异常则返回null
    E peek();               //获取队列头部元素，如果出现异常则返回null
}
~~~

## 2. 双端队列
- 双向队列(Deque),是Queue的一个子接口，双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构
- Java中，**LinkedList实现了Deaue接口，Deque继承自Queue**, 因为LinkedList进行插入、删除操作效率较高
~~~java
public interface Deque<E> extends Queue<E> {
    void addFirst(E e);     //插入头部，异常会报错
    void addLast(E e);      //插入尾部，异常会报错
    E getFirst();           //获取头部，异常会报错
    E getLast();            //获取尾部，异常会报错
    E removeFirst();        //移除头部，异常会报错
    E removeLast();         //移除尾部，异常会报错

    boolean offerFirst(E e);//插入头部，异常返回false
    boolean offerLast(E e); //插入尾部，异常返回false
    E peekFirst();          //获取头部，异常不报错
    E peekLast();           //获取尾部，异常不报错
    E pollFirst();          //移除头部，异常不报错
    E pollLast();           //移除尾部，异常不报错
}
~~~
- 一般直接使用LinkedList
  
~~~java
    Deque<String> deque = new LinkedList<String>();
~~~


## 3. 栈
- Stack类一般不建议使用，因为继承自Vector，vector是动态数组，所以**Stack可以对栈内任意位置的元素进行添加删除操作**，违背了栈设计的初衷，破坏了栈的结构，引发安全问题
- 可靠的栈操作由`Deque`接口和它的实现类提供，Deque是双端队列，能在两端进行插入和删除，当然也能在一端进行插入删除操作  
~~~java
    Deque<Integer> stack = new ArrayDeque<Integer>();
    Deque<Integer> stack = new LinkedList<Integer>();
~~~
- 然而，我们声明的仍然**是一个Deque**，可以在两端进行插入和删除！！
- 目前java官方只做到这个份上。一般用Deque，为了更安全可以自己再封装一层
- 常用方法：`push`，`pop`，`peak`，`isEmpty`
~~~java
public void push(E e) {addFirst(e);}    //异常报错
public void addFirst(E e) {
    if (e == null)
        throw new NullPointerException();   //抛出异常
    elements[head = (head - 1) & (elements.length - 1)] = e;
    if (head == tail)
        doubleCapacity();
}
~~~

~~~java
public E pop() {return removeFirst();}  //异常报错
public E removeFirst() {
    E x = pollFirst();
    if (x == null)
        throw new NoSuchElementException();
    return x;
}
~~~

~~~java
public E peek() {return peekFirst();}   //异常不会报错
public E peekFirst() {
    return (E) elements[head];  // elements[head] is null if deque empty
}
~~~

~~~java
public boolean isEmpty() {return head == tail;}
~~~



# 回溯算法
- 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会 **“剪枝”**，剪枝的意思也就是说对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化

## 1. 回溯与DFS
- 回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。  

## 2. 回溯算法框架
~~~java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        //做选择
        backtrack(路径, 选择列表)
        //撤销选择
~~~

## 3. 全排问题（LeetCode46）
- 输入一组不重复的数字，返回它们的全排列
~~~java
List<List<Integer>> res = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    // 记录「路径」
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
void backtrack(int[] nums, LinkedList<Integer> track) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (track.contains(nums[i]))
            continue;
        // 做选择
        track.add(nums[i]);
        // 进入下一层决策树
        backtrack(nums, track);
        // 取消选择
        track.removeLast();
    }
}
~~~
- 不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高

## 4. N皇后问题（LeetCode51）
-  N×N 的棋盘，放置 N 个皇后，使得它们不能互相攻击。皇后可以攻击同一行、同一列、左上左下右上右下在一条直线上的任意单位

~~~java
    private List<List<String>> result = new LinkedList<>();
    public List<List<String>> solveNQueens(int n) {
        backtrack(n, 0, new int[n]);    //int[n]存放解
        return result;
    }
    private void backtrack(int n, int row, int[] position){
        if(row==n){
            //记录结果
            List<String> list = new LinkedList<>();
            for(int x:position){
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < n; i++)
                    sb.append(i!=x?".":"Q");
                list.add(sb.toString());
            }
            result.add(list);
            return ;  //递归出口
        }
        for (int col = 0; col < n; col++) {   //对一个位置，验证
            //尝试选择
            position[row]=col;
            //验证
            if(!isValid(row,position))
                continue;
            //进入下一行决策
            backtrack(n, row+1, position);
            //撤销选择
        }
    }
    private boolean isValid(int row, int[] position){
        if(row==0) return true;
        for (int row_i = 0; row_i < row; row_i++) {
            if(position[row_i]==position[row] || position[row_i]==(position[row]+row-row_i)||position[row_i]==(position[row]-(row-row_i)))
                return false;
        }
        return true;
    }

    public static void main(String[] args) {
        List<List<String>> lists = new Demo51().solveNQueens(4);
        System.out.println(lists);
    }
~~~     

# BFS   
- BFS 的核心思想就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列
- BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多

## 1. BFS算法框架
~~~java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < q.size; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
~~~

# 二分查找  

- 总结：全部使用闭区间

## 1. 二分查找框架
- 计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出
- 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节
- ... 标记的部分，就是可能出现细节问题的地方

~~~java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
~~~

## 2. 二分查找目标值的索引
~~~java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
~~~
- 细节1：`left <= right`，因为搜索区间是 [left, right]，全部搜索完未找到的结束条件自然是 [right+1, right] 
- 细节2：`left = mid + 1`，正是因为搜索区间是闭区间，**mid 已经搜索过了**，所以排除mid

## 3. 二分查找侧边界

- 查找左边界

~~~java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    // 出循环的条件是 left=right+1
    while (left <= right) {     
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    // 检查出界情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
~~~

- 查找右边界

~~~java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 这里改为检查 right 越界的情况，见下图
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
~~~

# 树
## 1. 树的遍历
## 1.1 中序遍历
~~~java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        TreeNode p = root;
        Deque<TreeNode> stack = new ArrayDeque<>();
        while (!stack.isEmpty()||p!=null) {
            while(p!=null){
                stack.push(p);
                p = p.left;
            } 
            p = stack.pop();
            result.add(p.val);
            p = p.right;
        }
        return result;
    }
~~~

## 2. 2-3树和红黑树
### 2.1 BST树存在的问题
- BST的特点是 左孩子 < 根 < 右孩子
- BST只要求有序，不一定平衡，最坏情况的复杂度为O(n)
- 我们希望插入数据后保持树的特点，O(logn)的新功能，就需要对节点进行调整
![排序树存在的问题](https://s1.ax1x.com/2020/09/28/0Vsmlj.jpg)

### 2.2 2-3树-解决平衡问题
#### 2.2.1 2-3树的定义
如果一个内部节点拥有**一个数据元素、两个子节点**，则此节点为2节点。
如果一个内部节点拥有**两个数据元素、三个子节点**，则此节点为3节点。
当且仅当以下叙述中有一条成立时，T为2–3树：
- T 为空
- T 为拥有数据元素 a 的 2 节点，左孩子 L，右孩子 R，则：
  - L 和 R 都是**等高**的非空2-3树
  - a 大于 L 中的所有数据元素
  - a 小于 R 中的所有数据元素
- T为拥有数据元素 a 和 b 的 3 节点，其中a < b。若T的左孩子为L、中孩子为M、右孩子为R，则：
  - L、M、和 R 是**等高**的非空2–3树
  - a大于L中的所有数据元素，并且小于等于M中的所有数据元素
  - b大于M中的所有数据元素，并且小于等于R中的所有数据元素


2-3树允许在一个节点中存在两个元素，等元素数量等于3个的时候再进行调整，通过这种方式来保证整个二叉搜索树的平衡性

![AVL树和2-3树插入节点](https://s1.ax1x.com/2020/09/28/0VsWnI.jpg)

#### 2.2.2 2-3树的性质
- **2-3树的所有子叶节点都在同一层**
- 1个节点可以有1到2个数据，如果达到3个就要进行调整
- 1个节点存放一个数据时，有两个孩子节点
- 1个节点存放两个数据时，有三个孩子节点，中间子节点是介于两个节点之间的值

### 2.3 红黑树
#### 2.3.1 红黑树的定义
1. 一个节点要么是红色要么是黑色
2. 根节点是黑色
3. 所有叶子节点都是黑色(**叶子节点是NIL节点**)
4. 红色节点的两个孩子一定是黑色节点
5. 任意节点到每个叶节点的路径包含相同的黑节点数目(黑高)

![红黑树例子](https://s1.ax1x.com/2020/09/28/0VcMnA.png)
红黑树并不是一个完美平衡的二叉查找树，只是任意节点到子节点路径包含相同的黑色节点数目，所以也叫红黑树的这种平衡为**黑色完美平衡**
**红黑树从根到叶节点的最长路径不会超过最短路径的2倍**
#### 2.3.2 2-3树到红黑树的转换
- 红黑树是2-3树和2-3-4树的另一种表现形式，更利于编码实现，比较也更方便            
- 2-3-4树转红黑树主要需要考虑这三种不同节点的转换，如下图。其中正式由于3叉节点有两种情况，导致了转换成的红黑树产生左倾和右倾
![2-3-4树转红黑树规则](https://s1.ax1x.com/2020/09/28/0VROu4.jpg)

- 具体的转换例子如下：
![2-3-4树转红黑树例子](https://s1.ax1x.com/2020/09/28/0VRzU1.jpg)

#### 2.3.3 红黑树的平衡
为了让红黑树保持平衡状态，有染色和左右旋转两种方法，这两个方法都是从2-3树演化来的
- 左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子
![左旋转](https://s1.ax1x.com/2020/09/28/0V5Cod.png)
- 右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子
![右旋转](https://s1.ax1x.com/2020/09/28/0V59dH.jpg)

